/**
 * Subscribe represents our "streaming" subscription protocol.
 *
 * There is only one important RPC currently which models a generic description
 * to a topic-based pub-sub system. The state store published updates as Events.
 * The majority of this file is defining those event types.
 */
syntax = "proto3";

package agentpb;

import "structs.proto";
// Go Modules now includes the version in the filepath for packages within GOPATH/pkg/mode
// Therefore unless we want to hardcode a version here like
// github.com/gogo/protobuf@v1.3.0/gogoproto/gogo.proto then the only other choice is to
// have a more relative import and pass the right import path to protoc. I don't like it
// but its necessary.
import "gogoproto/gogo.proto";

option (gogoproto.goproto_unkeyed_all) = false;
option (gogoproto.goproto_unrecognized_all) = false;
option (gogoproto.goproto_getters_all) = false;
option (gogoproto.goproto_sizecache_all) = false;

// Topic enumerates the supported streaming topics in Consul.
enum Topic {
    ServiceHealth = 0;
    ServiceHealthConnect = 1;
    ACLTokens = 2;
    ACLPolicies = 3;
    ACLRoles = 4;
}

// SubscribeRequest is the type used to initiate a streaming Subscribe RPC.
message SubscribeRequest {
    // Topic identifies the set of events the subscriber is interested in.
    Topic Topic = 1;

    // Key is a topic-specific identifier that restricts the scope of the
    // subscription to only events pertaining to that identifier. For example
    // for watching the instances of a single service, the service's name is
    // specified as the key. An empty key indicates that all events in the topic
    // are of interest.
    string Key = 2;

    // Token is the ACL token to authenticate the request. The token must have
    // sufficient priviledges to read the requested information otherwise events
    // will be filtered, possibly resulting in an empty snapshot and no further
    // updates sent.
    string Token = 3;

    // Index is the raft index the subscriber has already observed up to. This
    // is zero on an initial streaming call, but then can be provided by a
    // client on subsequent reconnections such that the full snapshot doesn't
    // need to be resent if the client is up to date.
    uint64 Index = 4;

    // Filter optionally specified a bexpr filter string to apply to the event
    // objects before returning them. This is an optimization only and the
    // server MAY NOT filter the results. In general it may not be possible for
    // the server to correctly apply filters without keeping a history of every
    // object sent on the subscription which would be prohibitively costly. So
    // in general servers DO NOT filter streaming updates and rely on the client
    // to apply the filter before returning to the user. The server MAY use this
    // as a hint when shipping the initial snapshot of the result to reduce data
    // sent unnecessarily over the wire. Currently for health endpoint the
    // server ignores this entirely but we may change that later.
    string Filter = 5;

    // Datacenter specifies the Consul datacenter the request is targetted at.
    // If it's not the local DC (or empty) the server will forward the stream to
    // the remote DC and proxy the results back.
    string Datacenter = 6;
}

// Event describes a streaming update on a subscription. Events are used both to
// describe the current "snapshot" of the result as well as ongoing mutations to
// that snapshot.
message Event {
    // Topic the event was published to
    Topic Topic = 1;

    // Key is the logical identifier for the entity that was mutated.
    string Key = 2;

    // Index is the raft index at which the mutation took place. At the top
    // level of a subscription there will always be at most one Event per index.
    // If multiple events are published to the same topic in a single raft
    // transaction then the batch of events will be encoded inside a single
    // top-level event to ensure they are delivered atomically to clients.
    uint64 Index = 3;

    // Payload is the actual event content.
    oneof Payload {
        // ServiceHealth is used for ServiceHealth and ServiceHealthConnect
        // topics.
        ServiceHealthUpdate ServiceHealth = 5;

        // ACLToken represents a mutation of an ACLToken.
        ACLTokenUpdate ACLToken = 6;

        // ACLPolicy represents a mutation of an ACLPolicy.
        ACLPolicyUpdate ACLPolicy = 7;

        // ACLRole represents a mutation of an ACLRole.
        ACLRoleUpdate ACLRole = 8;

        // EndOfSnapshot indicates the event stream for the initial snapshot has
        // ended. Subsequent Events delivered will be mutations to that result.
        bool EndOfSnapshot = 9;

        // ResumeStream indicates that the client is still up-to-date, so there
        // will be no snapshot, and the rest of the stream will be individual
        // update events. It disambiguates between "up to date, no snapshot" and
        // "snapshot containes zero events".
        bool ResumeStream = 10;

        // ResetStream indicates the client should re-start the Subscribe call.
        // It is used when the server can no longer correctly maintain the
        // stream, for example because the ACL permisions for the token changed
        // and the server doesn't know which previously delivered events should
        // now not be visible. Clients when receiving this must reset their
        // local copy of the state to empty and start over from index 0 to get a
        // valid snapshot again. Servers may also send this if their state store
        // is restored from a snapshot.
        bool ResetStream = 11;

        // EventBatch is a set of events. This is typically used as the payload
        // type where multiple events are emitted in a single topic and raft
        // index (e.g. transactional updates). In this case the Topic and Index
        // values of all events will match and the whole set should be delivered
        // and consumed atomically.
        EventBatch EventBatch = 12;
    }
}

message EventBatch {
    repeated Event Events = 1;
}

enum CatalogOp {
    Register = 0;
    Deregister = 1;
}

enum ACLOp {
    Update = 0;
    Delete = 1;
}

enum ACLResource {
    ServiceACL = 0;
    NodeACL = 1;
}

message ServiceHealthUpdate {
    CatalogOp Op = 1;
    CheckServiceNode CheckServiceNode = 2;
}

message ACLTokenUpdate {
    ACLOp Op = 1;
    ACLTokenIdentifier Token = 2;
}

message ACLTokenIdentifier {
  // This is the UUID used for tracking and management purposes
  string AccessorID = 1;

  // This is the UUID used as the api token by clients. We shouldn't need this
  // just to identify tokens internally and hopefully can remove it soon but
  // there is still currently a short period after a 1.4.0+ server is upgraded
  // from pre 1.4.0 where legacy tokens may not have accessors yet.
  string SecretID = 2;
}

message ACLPolicyUpdate {
    ACLOp Op = 1;
    string PolicyID = 2;
}

message ACLRoleUpdate {
    ACLOp Op = 1;
    string RoleID = 2;
}