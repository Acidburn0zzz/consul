// Code generated by agentpb/structgen. DO NOT EDIT.

package agentpb

import (
	"testing"

	fuzz "github.com/google/gofuzz"
	"github.com/stretchr/testify/require"

	"github.com/hashicorp/consul/agent/structs"
)

func testFuzzer() *fuzz.Fuzzer {
	f := fuzz.New()
	f.NilChance(0)
	f.NumElements(1, 3)

	// Populate map[string]interface{} since gofuzz panics on these. We force them
	// to be interface{} rather than concrete types otherwise they won't compare
	// equal when coming back out the other side.
	f.Funcs(func(m map[string]interface{}, c fuzz.Continue) {
		// Populate it with some random stuff of different types
		// Int -> Float since trip through protobuf.Value will force this.
		m[c.RandString()] = interface{}(float64(c.RandUint64()))
		m[c.RandString()] = interface{}(c.RandString())
		m[c.RandString()] = interface{}([]interface{}{c.RandString(), c.RandString()})
		m[c.RandString()] = interface{}(map[string]interface{}{c.RandString(): c.RandString()})
	},
		func(i *int, c fuzz.Continue) {
			// Potentially controversial but all of the int values we care about
			// instructs are expected to be lower than 32 bits - if they weren't then
			// we'd use (u)int64 and would already be breaking 32-bit compat. So we
			// explicitly call those int32 in protobuf. But gofuzz will happily assign
			// them values out of range of an in32 so we need to restrict it or the trip
			// through PB truncates them and fails the tests.
			*i = int(int32(c.RandUint64()))
		},
		func(i *uint, c fuzz.Continue) {
			// See above
			*i = uint(uint32(c.RandUint64()))
		},
		func(v *structs.CheckTypes, c fuzz.Continue) {
			// For some reason gofuzz keeps populating structs.CheckTypes arrays with
			// nils even though NilChance is zero. It's probably a bug but I don't
			// have time to figure that out with a minimal repro and report it right
			// now. Just work around it.
			*v = make(structs.CheckTypes, 2)
			for i := range *v {
				ct := structs.CheckType{}
				c.Fuzz(&ct)
				(*v)[i] = &ct
			}
		})
	return f
}

func TestCheckServiceNodeStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.CheckServiceNode

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p CheckServiceNode
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestCheckTypeStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.CheckType

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p CheckType
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestConnectProxyConfigStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.ConnectProxyConfig

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p ConnectProxyConfig
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestEnterpriseMetaStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.EnterpriseMeta

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p EnterpriseMeta
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestExposeConfigStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.ExposeConfig

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p ExposeConfig
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestExposePathStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.ExposePath

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p ExposePath
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestHealthCheckStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.HealthCheck

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p HealthCheck
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestHealthCheckDefinitionStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.HealthCheckDefinition

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p HealthCheckDefinition
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestMeshGatewayConfigStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.MeshGatewayConfig

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p MeshGatewayConfig
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestNodeStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.Node

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p Node
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestNodeServiceStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.NodeService

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p NodeService
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestQueryMetaStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.QueryMeta

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p QueryMeta
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestQueryOptionsStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.QueryOptions

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p QueryOptions
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestRaftIndexStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.RaftIndex

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p RaftIndex
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestServiceAddressStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.ServiceAddress

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p ServiceAddress
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestServiceConnectStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.ServiceConnect

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p ServiceConnect
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestServiceDefinitionStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.ServiceDefinition

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p ServiceDefinition
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestUpstreamStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.Upstream

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p Upstream
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestWeightsStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.Weights

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p Weights
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}

func TestWriteRequestStructsConvert(t *testing.T) {
	// Create a "full" version of the structs package version. This should mean
	// any fields added to structs package but not mirrored in agentpb will cause
	// this test to fail.
	f := testFuzzer()
	var s structs.WriteRequest

	for i := 0; i < 10; i++ {
		f.Fuzz(&s)

		// Convert to protobuf and back
		var p WriteRequest
		require.NoError(t, p.FromStructs(&s))
		got, err := p.ToStructs()
		require.NoError(t, err)
		require.NotNil(t, got)
		require.Equal(t, s, *got)
	}
}
