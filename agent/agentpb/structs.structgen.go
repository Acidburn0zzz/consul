// Code generated by agentpb/structgen. DO NOT EDIT.

package agentpb

import (
	"github.com/hashicorp/consul/agent/structs"
)

// ToStructs converts the protobuf type to the original structs package type.
func (p *CheckServiceNode) ToStructs() (*structs.CheckServiceNode, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.CheckServiceNode{}
	tmpNode, err := p.Node.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpNode != nil {
		s.Node = tmpNode
	}
	tmpService, err := p.Service.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpService != nil {
		s.Service = tmpService
	}
	if p.Checks != nil {
		s.Checks = make(structs.HealthChecks, 0, len(p.Checks))
		for _, e := range p.Checks {
			tmp, err := e.ToStructs()
			if err != nil {
				return nil, err
			}
			if tmp != nil {
				s.Checks = append(s.Checks, tmp)
			}
		}
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *CheckServiceNode) FromStructs(s *structs.CheckServiceNode) error {
	if s == nil {
		return nil
	}

	if s.Node != nil {

		var tmpNode Node
		if err := tmpNode.FromStructs(s.Node); err != nil {
			return err
		}
		p.Node = &tmpNode
	}

	if s.Service != nil {

		var tmpService NodeService
		if err := tmpService.FromStructs(s.Service); err != nil {
			return err
		}
		p.Service = &tmpService
	}
	if s.Checks != nil {
		p.Checks = make([]*HealthCheck, 0, len(s.Checks))
		for _, e := range s.Checks {
			if e == nil {
				continue
			}
			var tmp HealthCheck
			if err := tmp.FromStructs(e); err != nil {
				return err
			}
			p.Checks = append(p.Checks, &tmp)
		}
	}
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *CheckType) ToStructs() (*structs.CheckType, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.CheckType{}
	s.CheckID = p.CheckID
	s.Name = p.Name
	s.Status = p.Status
	s.Notes = p.Notes
	if p.ScriptArgs != nil {
		s.ScriptArgs = make([]string, len(p.ScriptArgs))
		for i, e := range p.ScriptArgs {
			s.ScriptArgs[i] = e
		}
	}
	s.HTTP = p.HTTP
	if p.Header != nil {
		s.Header = make(map[string][]string, len(p.Header))
		for k, v := range p.Header {
			tmp, err := v.ToStructs()
			if err != nil {
				return nil, err
			}
			s.Header[k] = tmp
		}
	}
	s.Method = p.Method
	s.TCP = p.TCP
	s.Interval = p.Interval
	s.AliasNode = p.AliasNode
	s.AliasService = p.AliasService
	s.DockerContainerID = p.DockerContainerID
	s.Shell = p.Shell
	s.GRPC = p.GRPC
	s.GRPCUseTLS = p.GRPCUseTLS
	s.TLSSkipVerify = p.TLSSkipVerify
	s.Timeout = p.Timeout
	s.TTL = p.TTL
	s.SuccessBeforePassing = int(p.SuccessBeforePassing)
	s.FailuresBeforeCritical = int(p.FailuresBeforeCritical)
	s.ProxyHTTP = p.ProxyHTTP
	s.ProxyGRPC = p.ProxyGRPC
	s.DeregisterCriticalServiceAfter = p.DeregisterCriticalServiceAfter
	s.OutputMaxSize = int(p.OutputMaxSize)
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *CheckType) FromStructs(s *structs.CheckType) error {
	if s == nil {
		return nil
	}
	p.CheckID = s.CheckID
	p.Name = s.Name
	p.Status = s.Status
	p.Notes = s.Notes
	if s.ScriptArgs != nil {
		p.ScriptArgs = make([]string, len(s.ScriptArgs))
		for i, e := range s.ScriptArgs {
			p.ScriptArgs[i] = e
		}
	}
	p.HTTP = s.HTTP
	if s.Header != nil {
		p.Header = make(map[string]HeaderValue, len(s.Header))
		for k, v := range s.Header {
			var tmp HeaderValue
			if err := tmp.FromStructs(v); err != nil {
				return err
			}
			p.Header[k] = tmp
		}
	}
	p.Method = s.Method
	p.TCP = s.TCP
	p.Interval = s.Interval
	p.AliasNode = s.AliasNode
	p.AliasService = s.AliasService
	p.DockerContainerID = s.DockerContainerID
	p.Shell = s.Shell
	p.GRPC = s.GRPC
	p.GRPCUseTLS = s.GRPCUseTLS
	p.TLSSkipVerify = s.TLSSkipVerify
	p.Timeout = s.Timeout
	p.TTL = s.TTL
	p.SuccessBeforePassing = int32(s.SuccessBeforePassing)
	p.FailuresBeforeCritical = int32(s.FailuresBeforeCritical)
	p.ProxyHTTP = s.ProxyHTTP
	p.ProxyGRPC = s.ProxyGRPC
	p.DeregisterCriticalServiceAfter = s.DeregisterCriticalServiceAfter
	p.OutputMaxSize = int32(s.OutputMaxSize)
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *ConnectProxyConfig) ToStructs() (*structs.ConnectProxyConfig, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.ConnectProxyConfig{}
	s.DestinationServiceName = p.DestinationServiceName
	s.DestinationServiceID = p.DestinationServiceID
	s.LocalServiceAddress = p.LocalServiceAddress
	s.LocalServicePort = p.LocalServicePort
	s.Config = MapFromPBStruct(p.Config)
	if p.Upstreams != nil {
		s.Upstreams = make(structs.Upstreams, 0, len(p.Upstreams))
		for _, e := range p.Upstreams {
			tmp, err := e.ToStructs()
			if err != nil {
				return nil, err
			}
			if tmp != nil {
				s.Upstreams = append(s.Upstreams, *tmp)
			}
		}
	}
	tmpMeshGateway, err := p.MeshGateway.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpMeshGateway != nil {
		s.MeshGateway = *tmpMeshGateway
	}
	tmpExpose, err := p.Expose.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpExpose != nil {
		s.Expose = *tmpExpose
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *ConnectProxyConfig) FromStructs(s *structs.ConnectProxyConfig) error {
	if s == nil {
		return nil
	}
	p.DestinationServiceName = s.DestinationServiceName
	p.DestinationServiceID = s.DestinationServiceID
	p.LocalServiceAddress = s.LocalServiceAddress
	p.LocalServicePort = s.LocalServicePort
	p.Config = MapToPBStruct(s.Config)
	if s.Upstreams != nil {
		p.Upstreams = make([]Upstream, 0, len(s.Upstreams))
		for _, e := range s.Upstreams {

			var tmp Upstream
			if err := tmp.FromStructs(&e); err != nil {
				return err
			}
			p.Upstreams = append(p.Upstreams, tmp)
		}
	}

	var tmpMeshGateway MeshGatewayConfig
	if err := tmpMeshGateway.FromStructs(&s.MeshGateway); err != nil {
		return err
	}
	p.MeshGateway = &tmpMeshGateway

	var tmpExpose ExposeConfig
	if err := tmpExpose.FromStructs(&s.Expose); err != nil {
		return err
	}
	p.Expose = &tmpExpose

	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *EnterpriseMeta) ToStructs() (*structs.EnterpriseMeta, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.EnterpriseMeta{}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *EnterpriseMeta) FromStructs(s *structs.EnterpriseMeta) error {
	if s == nil {
		return nil
	}
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *ExposeConfig) ToStructs() (*structs.ExposeConfig, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.ExposeConfig{}
	s.Checks = p.Checks
	if p.Paths != nil {
		s.Paths = make([]structs.ExposePath, 0, len(p.Paths))
		for _, e := range p.Paths {
			tmp, err := e.ToStructs()
			if err != nil {
				return nil, err
			}
			if tmp != nil {
				s.Paths = append(s.Paths, *tmp)
			}
		}
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *ExposeConfig) FromStructs(s *structs.ExposeConfig) error {
	if s == nil {
		return nil
	}
	p.Checks = s.Checks
	if s.Paths != nil {
		p.Paths = make([]*ExposePath, 0, len(s.Paths))
		for _, e := range s.Paths {

			var tmp ExposePath
			if err := tmp.FromStructs(&e); err != nil {
				return err
			}
			p.Paths = append(p.Paths, &tmp)
		}
	}
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *ExposePath) ToStructs() (*structs.ExposePath, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.ExposePath{}
	s.ListenerPort = int(p.ListenerPort)
	s.Path = p.Path
	s.LocalPathPort = int(p.LocalPathPort)
	s.Protocol = p.Protocol
	s.ParsedFromCheck = p.ParsedFromCheck
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *ExposePath) FromStructs(s *structs.ExposePath) error {
	if s == nil {
		return nil
	}
	p.ListenerPort = int32(s.ListenerPort)
	p.Path = s.Path
	p.LocalPathPort = int32(s.LocalPathPort)
	p.Protocol = s.Protocol
	p.ParsedFromCheck = s.ParsedFromCheck
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *HealthCheck) ToStructs() (*structs.HealthCheck, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.HealthCheck{}
	s.Node = p.Node
	s.CheckID = p.CheckID
	s.Name = p.Name
	s.Status = p.Status
	s.Notes = p.Notes
	s.Output = p.Output
	s.ServiceID = p.ServiceID
	s.ServiceName = p.ServiceName
	if p.ServiceTags != nil {
		s.ServiceTags = make([]string, len(p.ServiceTags))
		for i, e := range p.ServiceTags {
			s.ServiceTags[i] = e
		}
	}
	s.Type = p.Type
	tmpDefinition, err := p.Definition.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpDefinition != nil {
		s.Definition = *tmpDefinition
	}
	tmpEnterpriseMeta, err := p.EnterpriseMeta.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpEnterpriseMeta != nil {
		s.EnterpriseMeta = *tmpEnterpriseMeta
	}
	tmpRaftIndex, err := p.RaftIndex.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpRaftIndex != nil {
		s.RaftIndex = *tmpRaftIndex
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *HealthCheck) FromStructs(s *structs.HealthCheck) error {
	if s == nil {
		return nil
	}
	p.Node = s.Node
	p.CheckID = s.CheckID
	p.Name = s.Name
	p.Status = s.Status
	p.Notes = s.Notes
	p.Output = s.Output
	p.ServiceID = s.ServiceID
	p.ServiceName = s.ServiceName
	if s.ServiceTags != nil {
		p.ServiceTags = make([]string, len(s.ServiceTags))
		for i, e := range s.ServiceTags {
			p.ServiceTags[i] = e
		}
	}
	p.Type = s.Type

	var tmpDefinition HealthCheckDefinition
	if err := tmpDefinition.FromStructs(&s.Definition); err != nil {
		return err
	}
	p.Definition = tmpDefinition

	var tmpEnterpriseMeta EnterpriseMeta
	if err := tmpEnterpriseMeta.FromStructs(&s.EnterpriseMeta); err != nil {
		return err
	}
	p.EnterpriseMeta = &tmpEnterpriseMeta

	var tmpRaftIndex RaftIndex
	if err := tmpRaftIndex.FromStructs(&s.RaftIndex); err != nil {
		return err
	}
	p.RaftIndex = tmpRaftIndex

	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *HealthCheckDefinition) ToStructs() (*structs.HealthCheckDefinition, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.HealthCheckDefinition{}
	s.HTTP = p.HTTP
	s.TLSSkipVerify = p.TLSSkipVerify
	if p.Header != nil {
		s.Header = make(map[string][]string, len(p.Header))
		for k, v := range p.Header {
			tmp, err := v.ToStructs()
			if err != nil {
				return nil, err
			}
			s.Header[k] = tmp
		}
	}
	s.Method = p.Method
	s.TCP = p.TCP
	s.Interval = p.Interval
	s.OutputMaxSize = uint(p.OutputMaxSize)
	s.Timeout = p.Timeout
	s.DeregisterCriticalServiceAfter = p.DeregisterCriticalServiceAfter
	if p.ScriptArgs != nil {
		s.ScriptArgs = make([]string, len(p.ScriptArgs))
		for i, e := range p.ScriptArgs {
			s.ScriptArgs[i] = e
		}
	}
	s.DockerContainerID = p.DockerContainerID
	s.Shell = p.Shell
	s.GRPC = p.GRPC
	s.GRPCUseTLS = p.GRPCUseTLS
	s.AliasNode = p.AliasNode
	s.AliasService = p.AliasService
	s.TTL = p.TTL
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *HealthCheckDefinition) FromStructs(s *structs.HealthCheckDefinition) error {
	if s == nil {
		return nil
	}
	p.HTTP = s.HTTP
	p.TLSSkipVerify = s.TLSSkipVerify
	if s.Header != nil {
		p.Header = make(map[string]HeaderValue, len(s.Header))
		for k, v := range s.Header {
			var tmp HeaderValue
			if err := tmp.FromStructs(v); err != nil {
				return err
			}
			p.Header[k] = tmp
		}
	}
	p.Method = s.Method
	p.TCP = s.TCP
	p.Interval = s.Interval
	p.OutputMaxSize = uint32(s.OutputMaxSize)
	p.Timeout = s.Timeout
	p.DeregisterCriticalServiceAfter = s.DeregisterCriticalServiceAfter
	if s.ScriptArgs != nil {
		p.ScriptArgs = make([]string, len(s.ScriptArgs))
		for i, e := range s.ScriptArgs {
			p.ScriptArgs[i] = e
		}
	}
	p.DockerContainerID = s.DockerContainerID
	p.Shell = s.Shell
	p.GRPC = s.GRPC
	p.GRPCUseTLS = s.GRPCUseTLS
	p.AliasNode = s.AliasNode
	p.AliasService = s.AliasService
	p.TTL = s.TTL
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *MeshGatewayConfig) ToStructs() (*structs.MeshGatewayConfig, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.MeshGatewayConfig{}
	s.Mode = p.Mode
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *MeshGatewayConfig) FromStructs(s *structs.MeshGatewayConfig) error {
	if s == nil {
		return nil
	}
	p.Mode = s.Mode
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *Node) ToStructs() (*structs.Node, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.Node{}
	s.ID = p.ID
	s.Node = p.Node
	s.Address = p.Address
	s.Datacenter = p.Datacenter
	if p.TaggedAddresses != nil {
		s.TaggedAddresses = make(map[string]string, len(p.TaggedAddresses))
		for i, e := range p.TaggedAddresses {
			s.TaggedAddresses[i] = e
		}
	}
	if p.Meta != nil {
		s.Meta = make(map[string]string, len(p.Meta))
		for i, e := range p.Meta {
			s.Meta[i] = e
		}
	}
	tmpRaftIndex, err := p.RaftIndex.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpRaftIndex != nil {
		s.RaftIndex = *tmpRaftIndex
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *Node) FromStructs(s *structs.Node) error {
	if s == nil {
		return nil
	}
	p.ID = s.ID
	p.Node = s.Node
	p.Address = s.Address
	p.Datacenter = s.Datacenter
	if s.TaggedAddresses != nil {
		p.TaggedAddresses = make(map[string]string, len(s.TaggedAddresses))
		for i, e := range s.TaggedAddresses {
			p.TaggedAddresses[i] = e
		}
	}
	if s.Meta != nil {
		p.Meta = make(map[string]string, len(s.Meta))
		for i, e := range s.Meta {
			p.Meta[i] = e
		}
	}

	var tmpRaftIndex RaftIndex
	if err := tmpRaftIndex.FromStructs(&s.RaftIndex); err != nil {
		return err
	}
	p.RaftIndex = tmpRaftIndex

	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *NodeService) ToStructs() (*structs.NodeService, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.NodeService{}
	s.Kind = p.Kind
	s.ID = p.ID
	s.Service = p.Service
	if p.Tags != nil {
		s.Tags = make([]string, len(p.Tags))
		for i, e := range p.Tags {
			s.Tags[i] = e
		}
	}
	s.Address = p.Address
	if p.TaggedAddresses != nil {
		s.TaggedAddresses = make(map[string]structs.ServiceAddress, len(p.TaggedAddresses))
		for k, v := range p.TaggedAddresses {
			tmp, err := v.ToStructs()
			if err != nil {
				return nil, err
			}
			s.TaggedAddresses[k] = *tmp

		}
	}
	if p.Meta != nil {
		s.Meta = make(map[string]string, len(p.Meta))
		for i, e := range p.Meta {
			s.Meta[i] = e
		}
	}
	s.Port = p.Port
	tmpWeights, err := p.Weights.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpWeights != nil {
		s.Weights = tmpWeights
	}
	s.EnableTagOverride = p.EnableTagOverride
	tmpProxy, err := p.Proxy.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpProxy != nil {
		s.Proxy = *tmpProxy
	}
	tmpConnect, err := p.Connect.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpConnect != nil {
		s.Connect = *tmpConnect
	}
	s.LocallyRegisteredAsSidecar = p.LocallyRegisteredAsSidecar
	tmpEnterpriseMeta, err := p.EnterpriseMeta.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpEnterpriseMeta != nil {
		s.EnterpriseMeta = *tmpEnterpriseMeta
	}
	tmpRaftIndex, err := p.RaftIndex.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpRaftIndex != nil {
		s.RaftIndex = *tmpRaftIndex
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *NodeService) FromStructs(s *structs.NodeService) error {
	if s == nil {
		return nil
	}
	p.Kind = s.Kind
	p.ID = s.ID
	p.Service = s.Service
	if s.Tags != nil {
		p.Tags = make([]string, len(s.Tags))
		for i, e := range s.Tags {
			p.Tags[i] = e
		}
	}
	p.Address = s.Address
	if s.TaggedAddresses != nil {
		p.TaggedAddresses = make(map[string]*ServiceAddress, len(s.TaggedAddresses))
		for k, v := range s.TaggedAddresses {
			var tmp ServiceAddress
			if err := tmp.FromStructs(&v); err != nil {
				return err
			}
			p.TaggedAddresses[k] = &tmp

		}
	}
	if s.Meta != nil {
		p.Meta = make(map[string]string, len(s.Meta))
		for i, e := range s.Meta {
			p.Meta[i] = e
		}
	}
	p.Port = s.Port

	if s.Weights != nil {

		var tmpWeights Weights
		if err := tmpWeights.FromStructs(s.Weights); err != nil {
			return err
		}
		p.Weights = &tmpWeights
	}
	p.EnableTagOverride = s.EnableTagOverride

	var tmpProxy ConnectProxyConfig
	if err := tmpProxy.FromStructs(&s.Proxy); err != nil {
		return err
	}
	p.Proxy = tmpProxy

	var tmpConnect ServiceConnect
	if err := tmpConnect.FromStructs(&s.Connect); err != nil {
		return err
	}
	p.Connect = tmpConnect

	p.LocallyRegisteredAsSidecar = s.LocallyRegisteredAsSidecar

	var tmpEnterpriseMeta EnterpriseMeta
	if err := tmpEnterpriseMeta.FromStructs(&s.EnterpriseMeta); err != nil {
		return err
	}
	p.EnterpriseMeta = &tmpEnterpriseMeta

	var tmpRaftIndex RaftIndex
	if err := tmpRaftIndex.FromStructs(&s.RaftIndex); err != nil {
		return err
	}
	p.RaftIndex = tmpRaftIndex

	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *QueryMeta) ToStructs() (*structs.QueryMeta, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.QueryMeta{}
	s.Index = p.Index
	s.LastContact = p.LastContact
	s.KnownLeader = p.KnownLeader
	s.ConsistencyLevel = p.ConsistencyLevel
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *QueryMeta) FromStructs(s *structs.QueryMeta) error {
	if s == nil {
		return nil
	}
	p.Index = s.Index
	p.LastContact = s.LastContact
	p.KnownLeader = s.KnownLeader
	p.ConsistencyLevel = s.ConsistencyLevel
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *QueryOptions) ToStructs() (*structs.QueryOptions, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.QueryOptions{}
	s.Token = p.Token
	s.MinQueryIndex = p.MinQueryIndex
	s.MaxQueryTime = p.MaxQueryTime
	s.AllowStale = p.AllowStale
	s.RequireConsistent = p.RequireConsistent
	s.UseCache = p.UseCache
	s.MaxStaleDuration = p.MaxStaleDuration
	s.MaxAge = p.MaxAge
	s.MustRevalidate = p.MustRevalidate
	s.StaleIfError = p.StaleIfError
	s.Filter = p.Filter
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *QueryOptions) FromStructs(s *structs.QueryOptions) error {
	if s == nil {
		return nil
	}
	p.Token = s.Token
	p.MinQueryIndex = s.MinQueryIndex
	p.MaxQueryTime = s.MaxQueryTime
	p.AllowStale = s.AllowStale
	p.RequireConsistent = s.RequireConsistent
	p.UseCache = s.UseCache
	p.MaxStaleDuration = s.MaxStaleDuration
	p.MaxAge = s.MaxAge
	p.MustRevalidate = s.MustRevalidate
	p.StaleIfError = s.StaleIfError
	p.Filter = s.Filter
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *RaftIndex) ToStructs() (*structs.RaftIndex, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.RaftIndex{}
	s.CreateIndex = p.CreateIndex
	s.ModifyIndex = p.ModifyIndex
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *RaftIndex) FromStructs(s *structs.RaftIndex) error {
	if s == nil {
		return nil
	}
	p.CreateIndex = s.CreateIndex
	p.ModifyIndex = s.ModifyIndex
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *ServiceAddress) ToStructs() (*structs.ServiceAddress, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.ServiceAddress{}
	s.Address = p.Address
	s.Port = p.Port
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *ServiceAddress) FromStructs(s *structs.ServiceAddress) error {
	if s == nil {
		return nil
	}
	p.Address = s.Address
	p.Port = s.Port
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *ServiceConnect) ToStructs() (*structs.ServiceConnect, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.ServiceConnect{}
	s.Native = p.Native
	tmpSidecarService, err := p.SidecarService.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpSidecarService != nil {
		s.SidecarService = tmpSidecarService
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *ServiceConnect) FromStructs(s *structs.ServiceConnect) error {
	if s == nil {
		return nil
	}
	p.Native = s.Native

	if s.SidecarService != nil {

		var tmpSidecarService ServiceDefinition
		if err := tmpSidecarService.FromStructs(s.SidecarService); err != nil {
			return err
		}
		p.SidecarService = &tmpSidecarService
	}
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *ServiceDefinition) ToStructs() (*structs.ServiceDefinition, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.ServiceDefinition{}
	s.Kind = p.Kind
	s.ID = p.ID
	s.Name = p.Name
	if p.Tags != nil {
		s.Tags = make([]string, len(p.Tags))
		for i, e := range p.Tags {
			s.Tags[i] = e
		}
	}
	s.Address = p.Address
	if p.TaggedAddresses != nil {
		s.TaggedAddresses = make(map[string]structs.ServiceAddress, len(p.TaggedAddresses))
		for k, v := range p.TaggedAddresses {
			tmp, err := v.ToStructs()
			if err != nil {
				return nil, err
			}
			s.TaggedAddresses[k] = *tmp

		}
	}
	if p.Meta != nil {
		s.Meta = make(map[string]string, len(p.Meta))
		for i, e := range p.Meta {
			s.Meta[i] = e
		}
	}
	s.Port = p.Port
	tmpCheck, err := p.Check.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpCheck != nil {
		s.Check = *tmpCheck
	}
	if p.Checks != nil {
		s.Checks = make(structs.CheckTypes, 0, len(p.Checks))
		for _, e := range p.Checks {
			tmp, err := e.ToStructs()
			if err != nil {
				return nil, err
			}
			if tmp != nil {
				s.Checks = append(s.Checks, tmp)
			}
		}
	}
	tmpWeights, err := p.Weights.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpWeights != nil {
		s.Weights = tmpWeights
	}
	s.Token = p.Token
	s.EnableTagOverride = p.EnableTagOverride
	tmpProxy, err := p.Proxy.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpProxy != nil {
		s.Proxy = tmpProxy
	}
	tmpEnterpriseMeta, err := p.EnterpriseMeta.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpEnterpriseMeta != nil {
		s.EnterpriseMeta = *tmpEnterpriseMeta
	}
	tmpConnect, err := p.Connect.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpConnect != nil {
		s.Connect = tmpConnect
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *ServiceDefinition) FromStructs(s *structs.ServiceDefinition) error {
	if s == nil {
		return nil
	}
	p.Kind = s.Kind
	p.ID = s.ID
	p.Name = s.Name
	if s.Tags != nil {
		p.Tags = make([]string, len(s.Tags))
		for i, e := range s.Tags {
			p.Tags[i] = e
		}
	}
	p.Address = s.Address
	if s.TaggedAddresses != nil {
		p.TaggedAddresses = make(map[string]*ServiceAddress, len(s.TaggedAddresses))
		for k, v := range s.TaggedAddresses {
			var tmp ServiceAddress
			if err := tmp.FromStructs(&v); err != nil {
				return err
			}
			p.TaggedAddresses[k] = &tmp

		}
	}
	if s.Meta != nil {
		p.Meta = make(map[string]string, len(s.Meta))
		for i, e := range s.Meta {
			p.Meta[i] = e
		}
	}
	p.Port = s.Port

	var tmpCheck CheckType
	if err := tmpCheck.FromStructs(&s.Check); err != nil {
		return err
	}
	p.Check = tmpCheck

	if s.Checks != nil {
		p.Checks = make([]*CheckType, 0, len(s.Checks))
		for _, e := range s.Checks {
			if e == nil {
				continue
			}
			var tmp CheckType
			if err := tmp.FromStructs(e); err != nil {
				return err
			}
			p.Checks = append(p.Checks, &tmp)
		}
	}

	if s.Weights != nil {

		var tmpWeights Weights
		if err := tmpWeights.FromStructs(s.Weights); err != nil {
			return err
		}
		p.Weights = &tmpWeights
	}
	p.Token = s.Token
	p.EnableTagOverride = s.EnableTagOverride

	if s.Proxy != nil {

		var tmpProxy ConnectProxyConfig
		if err := tmpProxy.FromStructs(s.Proxy); err != nil {
			return err
		}
		p.Proxy = &tmpProxy
	}

	var tmpEnterpriseMeta EnterpriseMeta
	if err := tmpEnterpriseMeta.FromStructs(&s.EnterpriseMeta); err != nil {
		return err
	}
	p.EnterpriseMeta = &tmpEnterpriseMeta

	if s.Connect != nil {

		var tmpConnect ServiceConnect
		if err := tmpConnect.FromStructs(s.Connect); err != nil {
			return err
		}
		p.Connect = &tmpConnect
	}
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *Upstream) ToStructs() (*structs.Upstream, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.Upstream{}
	s.DestinationType = p.DestinationType
	s.DestinationNamespace = p.DestinationNamespace
	s.DestinationName = p.DestinationName
	s.Datacenter = p.Datacenter
	s.LocalBindAddress = p.LocalBindAddress
	s.LocalBindPort = p.LocalBindPort
	s.Config = MapFromPBStruct(p.Config)
	tmpMeshGateway, err := p.MeshGateway.ToStructs()
	if err != nil {
		return nil, err
	}
	if tmpMeshGateway != nil {
		s.MeshGateway = *tmpMeshGateway
	}
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *Upstream) FromStructs(s *structs.Upstream) error {
	if s == nil {
		return nil
	}
	p.DestinationType = s.DestinationType
	p.DestinationNamespace = s.DestinationNamespace
	p.DestinationName = s.DestinationName
	p.Datacenter = s.Datacenter
	p.LocalBindAddress = s.LocalBindAddress
	p.LocalBindPort = s.LocalBindPort
	p.Config = MapToPBStruct(s.Config)

	var tmpMeshGateway MeshGatewayConfig
	if err := tmpMeshGateway.FromStructs(&s.MeshGateway); err != nil {
		return err
	}
	p.MeshGateway = &tmpMeshGateway

	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *Weights) ToStructs() (*structs.Weights, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.Weights{}
	s.Passing = p.Passing
	s.Warning = p.Warning
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *Weights) FromStructs(s *structs.Weights) error {
	if s == nil {
		return nil
	}
	p.Passing = s.Passing
	p.Warning = s.Warning
	return nil
}

// ToStructs converts the protobuf type to the original structs package type.
func (p *WriteRequest) ToStructs() (*structs.WriteRequest, error) {
	if p == nil {
		return nil, nil
	}
	s := structs.WriteRequest{}
	s.Token = p.Token
	return &s, nil
}

// FromStructs populates the protobuf type from an original structs package type.
func (p *WriteRequest) FromStructs(s *structs.WriteRequest) error {
	if s == nil {
		return nil
	}
	p.Token = s.Token
	return nil
}
